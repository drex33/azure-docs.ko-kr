---
title: 자습서 - Azure IoT Hub에 대한 암호화 및 X.509 인증서 이해 | Microsoft Docs
description: 자습서 - Azure IoT Hub에 대한 암호화 및 X.509 PKI 이해
author: v-gpettibone
ms.service: iot-hub
services: iot-hub
ms.topic: tutorial
ms.date: 02/25/2021
ms.author: robinsh
ms.custom:
- mvc
- 'Role: Cloud Development'
- 'Role: Data Analytics'
ms.openlocfilehash: 096d7bb1ca05f3d49c0b5c93751238f41e724ec6
ms.sourcegitcommit: 0046757af1da267fc2f0e88617c633524883795f
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/13/2021
ms.locfileid: "121724389"
---
# <a name="tutorial-understanding-public-key-cryptography-and-x509-public-key-infrastructure"></a>자습서: 공개 키 암호화 및 X.509 공개 키 인프라 이해

X.509 인증서를 사용하여 디바이스를 Azure IoT Hub에 인증할 수 있습니다. 인증서는 디바이스의 공개 키가 포함된 디지털 문서이며, 디바이스에서 주장하는 것임을 확인하는 데 사용할 수 있습니다. X.509 인증서 및 CRL(인증서 해지 목록)은 [RFC 5280](https://tools.ietf.org/html/rfc5280)에 설명되어 있습니다. 인증서는 X.509 PKI(공개 키 인프라)의 일부일 뿐입니다. X.509 PKI를 이해하려면 암호화 알고리즘, 암호화 키, 인증서 및 CA(인증 기관)를 이해해야 합니다.

* **알고리즘** 은 원본 일반 텍스트 데이터를 암호 텍스트로 변환하고 다시 일반 텍스트로 변환하는 방법을 정의합니다.
* **키** 는 알고리즘에 대한 입력으로 사용되는 임의(random) 또는 의사 임의(pseudorandom) 데이터 문자열입니다.
* **인증서** 는 엔터티의 공개 키가 포함된 디지털 문서이며, 이를 통해 인증서의 주체가 주장하는 사용자 또는 대상인지를 확인할 수 있습니다.
* **인증 기관** 은 인증서 주체의 신뢰성을 증명합니다.

인증서는 CA(인증 기관)에서 구입할 수 있습니다. 테스트 및 개발을 위해 또는 자체 포함 환경에서 작업하는 경우 자체 서명된 루트 CA를 만들 수도 있습니다. 예를 들어 하나 이상의 디바이스를 소유하고 IoT 허브 인증을 테스트하는 경우 루트 CA에 자체 서명하고 이를 사용하여 디바이스 인증서를 발급할 수 있습니다. 자체 서명된 디바이스 인증서를 발급할 수도 있습니다. 이에 대해서는 후속 문서에서 설명합니다.

먼저 인증서의 기반이 되는 암호화에 대해 설명한 후에 X.509 인증서에 대해 자세히 설명하고 이를 사용하여 디바이스를 IoT Hub에 인증합니다.

## <a name="cryptography"></a>암호화

암호화는 정보와 통신을 보호하는 데 사용됩니다. 이는 일반적으로 암호화 기술을 사용하여 일반 텍스트(통상적인 텍스트)를 암호 텍스트(인코딩된 텍스트)로 스크램블하고 다시 되돌리는 방식으로 수행됩니다. 이 스크램블링 프로세스를 암호화라고 하며, 이의 역방향 프로세스를 암호 해독이라고 합니다. 암호화와 관련된 목표는 다음과 같습니다.

* **기밀성**: 정보는 의도한 대상 그룹만 이해할 수 있습니다.
* **무결성**: 정보는 저장 또는 전송 중에 변경할 수 없습니다.
* **부인 방지**: 정보 작성자는 나중에 해당 작성을 거부할 수 없습니다.
* **인증**: 발신자와 수신자는 서로의 ID를 확인할 수 있습니다.

## <a name="encryption"></a>암호화

암호화 프로세스에는 알고리즘과 키가 필요합니다. 알고리즘은 데이터를 일반 텍스트에서 암호 텍스트로 변환하고 다시 일반 텍스트로 변환하는 방법을 정의합니다. 키는 알고리즘에 대한 입력으로 사용되는 임의의 데이터 문자열입니다. 프로세스의 모든 보안은 키에 포함됩니다. 따라서 키를 안전하게 저장해야 합니다. 그러나 가장 인기 있는 알고리즘의 세부 정보는 공개적으로 사용할 수 있습니다.

두 가지 유형의 암호화가 있습니다. 대칭 암호화는 동일한 키를 암호화와 암호 해독 모두에 사용합니다. 비대칭 암호화는 다르지만 수학적으로 관련된 키를 사용하여 암호화 및 암호 해독을 수행합니다.

### <a name="symmetric-encryption"></a>대칭 암호화

대칭 암호화는 동일한 키를 사용하여 일반 텍스트를 암호 텍스트로 암호화하고 암호 텍스트를 일반 텍스트로 다시 해독합니다. 비트 수로 표현되는 키의 필요한 길이는 알고리즘에 따라 결정됩니다. 키를 사용하여 일반 텍스트를 암호화하면 암호화된 메시지를 수신자에게 보내고 수신자는 암호 텍스트를 해독합니다. 대칭 키는 수신자에게 안전하게 전송해야 합니다. 대칭 알고리즘을 사용하는 경우 키를 보내는 것은 가장 심각한 보안 위험이 됩니다.

![대칭 암호화 예](media/tutorial-x509-introduction/symmetric-keys.png)

### <a name="asymmetric-encryption"></a>비대칭 암호화

대칭 암호화만 사용하는 경우 통신의 모든 당사자가 프라이빗 키를 소유해야 한다는 것이 문제입니다. 그러나 권한 없는 제3자가 권한 있는 사용자에게 전송하는 중에 키를 캡처할 수 있습니다. 이 문제를 해결하려면 비대칭 암호화 또는 공개 키 암호화를 대신 사용합니다.

비대칭 암호화에서는 모든 사용자에게 키 쌍이라고 하는 수학적으로 관련된 두 개의 키가 있습니다. 하나는 공개 키이고, 다른 하나는 프라이빗 키입니다. 키 쌍은 수신자만 데이터 암호 해독에 필요한 프라이빗 키에 액세스할 수 있도록 합니다. 다음 그림에서는 비대칭 암호화 프로세스를 요약하고 있습니다.

![비대칭 암호화 예](media/tutorial-x509-introduction/asymmetric-keys.png)

1. 수신자가 공개 키-프라이빗 키 쌍을 만들고 공개 키를 CA에 보냅니다. CA는 공개 키를 X.509 인증서에 패키지합니다.

1. 발신자가 CA로부터 수신자의 공개 키를 가져옵니다.

1. 발신자가 암호화 알고리즘을 사용하여 일반 텍스트 데이터를 암호화합니다. 수신자의 공개 키는 암호화를 수행하는 데 사용됩니다.

1. 발신자가 수신자에게 암호 텍스트를 전송합니다. 수신자에게 암호 텍스트를 해독하는 데 필요한 프라이빗 키가 이미 있으므로 키를 보낼 필요가 없습니다.

1. 수신자가 지정된 비대칭 알고리즘과 프라이빗 키를 사용하여 암호 텍스트를 해독합니다.

### <a name="combining-symmetric-and-asymmetric-encryption"></a>대칭 및 비대칭 암호화 결합

대칭 암호화와 비대칭 암호화를 결합하여 상대적인 장점을 활용할 수 있습니다. 대칭 암호화는 비대칭 암호화보다 훨씬 더 빠르지만 다른 당사자에게 프라이빗 키를 보내야 하므로 안전하지 않습니다. 두 유형을 함께 결합하기 위해 대칭 암호화를 사용하여 일반 텍스트를 암호 텍스트로 변환할 수 있습니다. 비대칭 암호화는 대칭 키를 교환하는 데 사용됩니다. 다음 다이어그램에서는 이를 보여 줍니다.

![대칭 및 비대칭 암호화](media/tutorial-x509-introduction/symmetric-asymmetric-encryption.png)

1. 발신자가 수신자의 공개 키를 검색합니다.

1. 발신자가 대칭 키를 생성하고, 이를 사용하여 원본 데이터를 암호화합니다.

1. 발신자가 수신자의 공개 키를 사용하여 대칭 키를 암호화합니다.

1. 발신자가 암호화된 대칭 키와 암호 텍스트를 의도한 수신자에게 전송합니다.

1. 수신자가 수신자의 공개 키와 일치하는 프라이빗 키를 사용하여 발신자의 대칭 키를 해독합니다.

1. 수신자가 대칭 키를 사용하여 암호 텍스트를 해독합니다.

### <a name="asymmetric-signing"></a>비대칭 서명

비대칭 알고리즘을 사용하여 데이터가 수정되지 않도록 보호하고 데이터 작성자의 ID를 증명할 수 있습니다. 다음 그림에서는 비대칭 서명이 발신자의 ID를 증명하는 데 도움이 되는 방법을 보여 줍니다.

![비대칭 서명 예](media/tutorial-x509-introduction/asymmetric-signing.png)

1. 발신자가 프라이빗 키를 암호화에 사용하여 비대칭 암호화 알고리즘을 통해 일반 텍스트 데이터를 전달합니다. 이 시나리오에서는 비대칭 암호화에 대해 자세히 설명하는 이전 섹션에서 설명한 프라이빗 키 및 공개 키를 역방향으로 사용합니다.

1. 결과 암호 텍스트가 수신자에게 전송됩니다.

1. 수신자가 디렉터리에서 발신자의 공개 키를 가져옵니다.

1. 수신자가 발신자의 공개 키를 사용하여 암호 텍스트를 해독합니다. 발신자만 원본 텍스트를 처음 암호화한 프라이빗 키에 액세스할 수 있으므로 결과 일반 텍스트는 발신자의 ID를 증명합니다.

## <a name="signing"></a>서명

디지털 서명을 사용하여 데이터가 전송 중 또는 미사용 중에 수정되었는지 여부를 확인할 수 있습니다. 데이터는 지정된 메시지에서 수학적 결과를 생성하는 단방향 함수인 해시 알고리즘을 통해 전달됩니다. 결과를 *해시 값*, *메시지 다이제스트*, *다이제스트*, *서명* 또는 *지문* 이라고 합니다. 해시 값은 원본 메시지를 가져오기 위해 되돌릴 수 없습니다. 메시지를 조금만 변경하면 *지문* 이 크게 변경되므로 해시 값을 사용하여 메시지가 변경되었는지 여부를 확인할 수 있습니다. 다음 그림에서는 비대칭 암호화 및 해시 알고리즘을 사용하여 메시지가 수정되지 않았는지 여부를 확인하는 방법을 보여 줍니다.

![서명 예](media/tutorial-x509-introduction/signing.png)

1. 발신자가 일반 텍스트 메시지를 만듭니다.

1. 발신자가 일반 텍스트 메시지를 해시하여 메시지 다이제스트를 만듭니다.

1. 발신자가 프라이빗 키를 사용하여 다이제스트를 암호화합니다.

1. 발신자가 일반 텍스트 메시지와 암호화된 다이제스트를 의도한 수신자에게 전송합니다.

1. 수신자가 발신자의 공개 키를 사용하여 다이제스트의 암호를 해독합니다.

1. 수신자는 발신자가 메시지에 사용한 것과 동일한 해시 알고리즘을 실행합니다.

1. 수신자가 결과 서명을 암호 해독된 서명과 비교합니다. 다이제스트가 동일하면 메시지가 전송 중에 수정되지 않은 것입니다.

## <a name="next-steps"></a>다음 단계

인증서를 구성하는 필드에 대해 자세히 알아보려면 [X.509 공개 키 인증서 이해](tutorial-x509-certificates.md)를 참조하세요.

X.509 인증서에 대해 이미 많이 알고 있고 IoT Hub에 인증하는 데 사용할 수 있는 테스트 버전을 생성하려면 다음 항목을 참조하세요.

* [Microsoft에서 제공하는 스크립트를 사용하여 테스트 인증서 만들기](tutorial-x509-scripts.md)
* [OpenSSL을 사용하여 테스트 인증서 만들기](tutorial-x509-openssl.md)
* [OpenSSL을 사용하여 자체 서명된 테스트 인증서 만들기](tutorial-x509-self-sign.md)

CA(인증 기관) 인증서 또는 하위 CA 인증서가 있고 이를 IoT 허브에 업로드하고 해당 인증서를 소유하고 있음을 증명하려면 [CA 인증서 소유 증명](tutorial-x509-prove-possession.md)을 참조하세요.
