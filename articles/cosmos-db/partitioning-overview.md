---
title: Azure Cosmos DB의 분할 및 수평적 크기 조정
description: Azure Cosmos DB의 분할, 논리 파티션 및 실제 파티션, 파티션 키 선택 시 모범 사례, 논리 파티션 관리 방법에 대해 알아봅니다.
author: deborahc
ms.author: dech
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 04/07/2021
ms.openlocfilehash: 099c65143f29f4fdf341b52e5d80731f1bdb0808
ms.sourcegitcommit: d40ffda6ef9463bb75835754cabe84e3da24aab5
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/07/2021
ms.locfileid: "107031004"
---
# <a name="partitioning-and-horizontal-scaling-in-azure-cosmos-db"></a>Azure Cosmos DB의 분할 및 수평적 크기 조정
[!INCLUDE[appliesto-all-apis](includes/appliesto-all-apis.md)]

Azure Cosmos DB에서는 애플리케이션의 성능 요구 사항을 충족하기 위해 분할을 사용하여 데이터베이스의 개별 컨테이너 크기를 조정합니다. 분할 시 컨테이너의 항목이 *논리 파티션* 이라고 하는 고유한 하위 집합으로 나뉩니다. 논리 파티션은 컨테이너의 각 항목과 연결된 *파티션 키* 의 값에 따라 구성됩니다. 논리 파티션의 모든 항목은 동일한 파티션 키 값을 갖습니다.

예를 들어 컨테이너는 항목을 포함합니다. 각 항목에는 `UserID` 속성에 대한 고유한 값이 있습니다. `UserID`가 컨테이너에 있는 항목의 파티션 키 역할을 하고 1,000개의 고유한 `UserID` 값이 있다면 컨테이너에 대해 1,000개의 논리 파티션이 생성됩니다.

항목의 논리 파티션을 결정하는 파티션 키 외에도 컨테이너의 각 항목에는 논리 파티션 내에서 고유한 *항목 ID* 가 있습니다. 파티션 키와 *항목 ID* 를 결합하면 항목의 *인덱스* 가 생성되며 이를 통해 항목을 고유하게 식별할 수 있습니다. [파티션 키 선택](#choose-partitionkey)은 애플리케이션 성능에 영향을 주는 중요한 결정입니다.

이 문서에서는 논리 파티션 및 실제 파티션 간의 관계를 설명합니다. 또한 분할에 대한 모범 사례를 설명하고 Azure Cosmos DB에서 수평적 크기 조정이 작동하는 방식에 대한 자세한 보기를 제공합니다. 파티션 키를 선택하기 위해 이러한 내부적인 정보를 자세히 알 필요는 없지만 Azure Cosmos DB 작동 방식을 명확하게 파악할 수 있도록 이 내용을 다루었습니다.

## <a name="logical-partitions"></a>논리 파티션

논리 파티션은 파티션 키가 동일한 항목 세트로 구성됩니다. 예를 들어 식품 영양에 대한 데이터가 포함된 컨테이너의 모든 항목에는 `foodGroup` 속성이 포함됩니다. `foodGroup`을 컨테이너에 대한 파티션 키로 사용할 수 있습니다. `foodGroup`에 대해 `Beef Products`, `Baked Products` 및 `Sausages and Luncheon Meats` 등의 특정 값을 갖는 항목 그룹은 고유한 논리 파티션을 형성합니다.

또한 논리 파티션은 데이터베이스 트랜잭션의 범위를 정의합니다. [스냅샷 격리가 있는 트랜잭션](database-transactions-optimistic-concurrency.md)을 사용하여 논리 파티션 내의 항목을 업데이트할 수 있습니다. 컨테이너에 새 항목이 추가되면 시스템에서 새 논리 파티션이 투명하게 만들어집니다. 기본 데이터를 삭제하는 경우 논리 파티션 삭제에 대해 걱정할 필요는 없습니다.

컨테이너의 논리 파티션 수에는 제한이 없습니다. 각 논리 파티션은 최대 20GB의 데이터를 저장할 수 있습니다. 양호한 파티션 키 선택 항목에는 다양한 값을 사용할 수 있습니다. 예를 들어 모든 항목에 `foodGroup` 속성이 포함된 컨테이너에서 `Beef Products` 논리 파티션 내의 데이터는 최대 20GB까지 증가할 수 있습니다. 다양한 값을 사용할 수 있는 [파티션 키를 선택](#choose-partitionkey)하면 컨테이너 크기를 조정할 수 있습니다.

## <a name="physical-partitions"></a>실제 파티션

컨테이너 크기는 실제 파티션에서 데이터와 처리량을 분산시켜 조정합니다. 내부적으로 하나 이상의 논리 파티션이 하나의 실제 파티션에 매핑됩니다. 일반적으로 작은 컨테이너에는 많은 논리 파티션이 있지만 실제 파티션은 하나만 필요합니다. 논리 파티션과 달리 실제 파티션은 시스템의 내부 구현이며 완전히 Azure Cosmos DB에서 관리합니다.

컨테이너의 실제 파티션 수는 다음에 따라 달라집니다.

* 프로비전된 처리량의 수(각 개별 실제 파티션은 초당 최대 10,000개의 요청 단위의 처리량을 제공할 수 있습니다.) 실제 파티션에 대한 10,000RU/s 제한은 각 논리 파티션이 하나의 실제 파티션에만 매핑되므로 논리 파티션에도 10,000RU/s 제한이 있음을 의미합니다.

* 총 데이터 스토리지(각 개별 실제 파티션은 최대 50GB의 데이터를 저장할 수 있습니다.)

> [!NOTE]
> 실제 파티션은 시스템의 내부 구현이며 완전히 Azure Cosmos DB에서 관리합니다. 솔루션을 개발할 때는 실제 파티션을 제어할 수 없으므로 실제 파티션에 집중하지 않도록 하세요. 대신, 파티션 키에 집중하세요. 논리 파티션 간에 처리량 소비를 균등하게 분산하는 파티션 키를 선택하면 실제 파티션의 처리량 소비에서 균형을 유지할 수 있습니다.

컨테이너의 전체 논리 파티션 수에는 제한이 없습니다. 프로비전된 처리량 또는 데이터 크기가 증가하면 Azure Cosmos DB는 기존 파티션을 분할하여 새 실제 파티션을 자동으로 만듭니다. 실제 파티션 분할은 애플리케이션의 가용성에 영향을 주지 않습니다. 실제 파티션이 분할된 후에도 단일 논리 파티션 내의 모든 데이터는 여전히 동일한 실제 파티션에 저장되어 있습니다. 실제 파티션을 분할하면 단순히 실제 파티션에 대한 논리 파티션의 새로운 매핑이 생성됩니다.

컨테이너에 대해 프로비전된 처리량은 실제 파티션 간에 균등하게 분할됩니다. 요청을 균등하게 분산하지 않는 파티션 키 디자인에서는 "핫" 파티션이 되는 작은 파티션 하위 집합으로 전달되는 요청이 너무 많아질 수 있습니다. 핫 파티션은 프로비전된 처리량을 비효율적으로 사용하게 되므로 속도가 제한되고 더 높은 비용이 발생할 수 있습니다.

Azure Portal **메트릭 블레이드** 의 **스토리지** 섹션에서 컨테이너의 실제 파티션을 확인할 수 있습니다.

:::image type="content" source="./media/partitioning-overview/view-partitions-zoomed-out.png" alt-text="실제 파티션 수 보기" lightbox="./media/partitioning-overview/view-partitions-zoomed-in.png" ::: 

위의 스크린 샷에서 컨테이너에는 `/foodGroup`을 파티션 키로 사용합니다. 그래프에 표시된 세 개의 막대는 각각 실제 파티션을 나타냅니다. 이미지에서 **파티션 키 범위** 는 실제 파티션과 동일합니다. 선택한 실제 파티션에는 크기가 가장 큰 3개의 논리 파티션인 `Beef Products`, `Vegetable and Vegetable Products`, `Soups, Sauces, and Gravies`가 포함됩니다.

18,000개 RU/s(초당 요청 단위)의 처리량을 프로비전하는 경우 세 개의 실제 파티션은 각각 프로비전된 총 처리량의 1/3을 활용할 수 있습니다. 선택한 실제 파티션 내에서 논리 파티션 키, `Beef Products`, `Vegetable and Vegetable Products` 및 `Soups, Sauces, and Gravies`는 전체적으로 실제 파티션의 초당 6,000개의 프로비전된 RU를 활용할 수 있습니다. 프로비전된 처리량은 컨테이너의 실제 파티션에서 균등하게 분할되므로 [올바른 논리 파티션 키를 선택](#choose-partitionkey)하여 소비되는 처리량을 균등하게 분산하는 파티션 키를 선택하는 것이 중요합니다. 

## <a name="managing-logical-partitions"></a>논리 파티션 관리

Azure Cosmos DB는 컨테이너의 확장성 및 성능 요구 사항을 효율적으로 충족하기 위해 실제 파티션에 논리 파티션을 배치하는 작업을 투명하게 자동으로 관리합니다. 애플리케이션의 처리량 및 스토리지 요구 사항이 증가하면 Azure Cosmos DB는 논리 파티션을 이동하여 자동으로 부하를 많은 수의 실제 파티션에 분산합니다. [실제 파티션](partitioning-overview.md#physical-partitions)에 대해 자세히 알아볼 수 있습니다.

Azure Cosmos DB는 해시 기반 분할을 사용하여 논리 파티션을 실제 파티션 간에 분산합니다. Azure Cosmos DB는 항목의 파티션 키 값을 해시합니다. 해시된 결과에 따라 실제 파티션이 달라집니다. 그런 다음, Azure Cosmos DB는 실제 파티션에 걸쳐 균등하게 파티션 키 해시의 주요 공간을 할당합니다.

저장 프로시저 또는 트리거의 트랜잭션은 단일 논리 파티션의 항목에만 허용됩니다.

## <a name="replica-sets"></a>복제본 세트

각 실제 파티션은 [*복제본 세트*](global-dist-under-the-hood.md)로도 불리는 일련의 복제본으로 구성됩니다. 각 복제본 세트는 데이터베이스 엔진의 인스턴스를 호스트합니다. 복제본 세트는 실제 파티션 내에 저장된 데이터를 내구성과 가용성이 높고 일관되게 만듭니다. 실제 파티션을 구성하는 각 복제본은 파티션의 스토리지 할당량을 상속합니다. 실제 파티션의 모든 복제본은 실제 파티션에 할당된 처리량을 전체적으로 지원합니다. Azure Cosmos DB는 복제본 세트를 자동으로 관리합니다.

일반적으로 작은 컨테이너에는 하나의 실제 파티션만 필요하지만 4개 이상의 복제본이 있어야 합니다.

다음 이미지에서는 논리 파티션이 전역적으로 배포된 실제 파티션에 매핑되는 방법을 보여 줍니다.

:::image type="content" source="./media/partitioning-overview/logical-partitions.png" alt-text="Azure Cosmos DB 분할을 보여 주는 이미지" border="false":::

## <a name="choosing-a-partition-key"></a><a id="choose-partitionkey"></a>파티션 키 선택

파티션 키에는 **파티션 키 경로** 와 **파티션 키 값** 의 두 가지 구성 요소가 있습니다. 예를 들어 { "userId" : "Andrew", "worksFor": "Microsoft" } 항목을 생각해 보면 파티션 키로 "userId"를 선택하는 경우 다음 두 가지 파티션 키 구성 요소가 있습니다.

* 파티션 키 경로(예: "/userId"). 파티션 키 경로에는 영숫자 및 밑줄(_)이 허용됩니다. 또한 표준 경로 표기법(/)을 사용하면 중첩된 개체를 사용할 수도 있습니다.

* 파티션 키 값(예: "Andrew"). 파티션 키 값은 문자열 또는 숫자 형식일 수 있습니다.

파티션 키의 처리량, 스토리지 및 길이에 대한 제한 사항을 자세히 알아보려면 [Azure Cosmos DB 서비스 할당량](concepts-limits.md) 문서를 참조하세요.

Azure Cosmos DB에서 파티션 키를 선택하는 것은 간단하지만 중요한 디자인 선택 사항입니다. 파티션 키를 선택하고 나면 해당 키를 그대로 변경할 수 없습니다. 파티션 키를 변경해야 하는 경우에는 필요한 새 파티션 키를 사용하여 새 컨테이너로 데이터를 이동해야 합니다.

**모든** 컨테이너에 대해 파티션 키는 다음과 같아야 합니다.

* 값이 변경되지 않는 속성이어야 합니다. 속성이 파티션 키인 경우 해당 속성의 값을 업데이트할 수 없습니다.

* 카디널리티가 높습니다. 즉, 속성에는 다양한 값을 사용할 수 있어야 합니다.

* 모든 논리 파티션에 RU(요청 단위) 사용량과 데이터 스토리지를 균등하게 분산합니다. 이렇게 하면 실제 파티션에서도 균등한 RU 사용량과 스토리지 배포가 가능합니다.

Azure Cosmos DB에서 [다중 항목 ACID 트랜잭션](database-transactions-optimistic-concurrency.md#multi-item-transactions)이 필요한 경우에는 [저장 프로시저 또는 트리거](how-to-write-stored-procedures-triggers-udfs.md#stored-procedures)를 사용해야 합니다. 모든 JavaScript 기반 저장 프로시저와 트리거는 단일 논리 파티션으로 범위가 한정됩니다.

## <a name="partition-keys-for-read-heavy-containers"></a>읽기 작업이 많은 컨테이너에 대한 파티션 키

대부분의 컨테이너에서 파티션 키를 선택할 때 위의 기준을 고려해야 합니다. 그러나 읽기 작업이 많은 컨테이너의 경우 쿼리에 필터로 자주 나타나는 파티션 키를 선택하는 것이 좋습니다. 필터 조건자에 파티션 키를 포함하여 쿼리를 [관련 물리 파티션에만 효율적으로 라우팅](how-to-query-container.md#in-partition-query)할 수 있습니다.

대부분의 워크로드 요청이 쿼리이고 대부분의 쿼리에 동일한 속성에 대한 동등성 필터가 있는 경우 이 속성은 양호한 파티션 키 선택이 될 수 있습니다. 예를 들어 `UserID`를 필터링하는 쿼리를 자주 실행하는 경우 `UserID`를 파티션 키로 선택하면 [파티션 간 쿼리](how-to-query-container.md#avoiding-cross-partition-queries) 수가 줄어듭니다.

그러나 컨테이너가 작은 경우 파티션 간 쿼리의 성능 영향을 걱정해야 할 정도로 물리적 파티션이 충분하지 않을 수 있습니다. Azure Cosmos DB에서 대부분의 작은 컨테이너는 하나 또는 두 개의 실제 파티션만 필요합니다.

컨테이너가 몇 개의 실제 파티션으로 확장될 수 있는 경우 파티션 간 쿼리를 최소화하는 파티션 키를 선택해야 합니다. 다음 중 하나에 해당하는 경우 컨테이너에는 몇 개의 실제 파티션이 필요합니다.

* 컨테이너에서 30,000개 이상의 RU가 프로비전된 경우

* 컨테이너가 100GB 이상의 데이터를 저장하는 경우

## <a name="using-item-id-as-the-partition-key"></a>항목 ID를 파티션 키로 사용

컨테이너에 다양한 범위의 사용 가능한 값이 포함된 속성이 있는 경우 양호한 파티션 키 선택일 수 있습니다. 이러한 속성의 가능한 한 가지 예는 *항목 ID* 입니다. 읽기 작업이 많은 작은 컨테이너 또는 크기에 관계 없이 쓰기 작업이 많은 컨테이너의 경우, 기본적으로 *항목 ID* 는 파티션 키에 적합합니다.

컨테이너의 모든 항목에 시스템 속성 *항목 ID* 가 있습니다. 항목의 논리적 ID를 나타내는 다른 속성이 있을 수 있습니다. 또한 대부분의 경우 *항목 ID* 와 동일한 이유에 적합한 파티션 키 선택입니다.

*항목 ID* 는 다음과 같은 이유로 적합한 파티션 키입니다.

* 가능한 값이 광범위합니다(항목당 하나의 고유 *항목 ID*).
* 항목별 고유 *항목 ID* 가 있기 때문에 *항목 ID* 는 RU 사용량과 데이터 스토리지를 균등하게 분산할 때 적합합니다.
* *항목 ID* 를 알고 있는 경우 항상 항목의 파티션 키를 알 수 있으므로 효율적인 시점 읽기를 쉽게 수행할 수 있습니다.

*항목 ID* 를 파티션 키로 선택하는 경우 고려해야 할 몇 가지 사항은 다음과 같습니다.

* *항목 ID* 가 파티션 키인 경우 전체 컨테이너에서 고유 식별자로 사용됩니다. 중복 *항목 ID* 가 있는 항목은 포함할 수 없습니다.
* 많은 [실제 파티션](partitioning-overview.md#physical-partitions)을 사용하는 컨테이너에 읽기 작업이 많은 경우 쿼리는 해당 *항목 ID* 를 사용하는 동등성 필터가 있으면 더 효율적입니다.
* 여러 논리 파티션에 걸쳐 저장 프로시저나 트리거를 실행할 수는 없습니다.

## <a name="next-steps"></a>다음 단계

* [Azure Cosmos DB에서 프로비전된 처리량](request-units.md)에 대한 자세한 정보
* [Azure Cosmos DB에서 글로벌 배포](distribute-data-globally.md)에 대한 자세한 정보
* [Azure Cosmos 컨테이너의 처리량을 프로비전](how-to-provision-container-throughput.md)하는 방법을 알아봅니다.
* [Azure Cosmos 데이터베이스의 처리량을 프로비전](how-to-provision-database-throughput.md)하는 방법을 알아봅니다.
