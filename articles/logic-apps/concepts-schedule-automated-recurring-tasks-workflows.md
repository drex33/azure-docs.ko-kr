---
title: Azure Logic Apps에서 반복적인 작업 및 워크플로 예약
description: Azure Logic Apps를 사용하여 반복적인 자동화된 작업, 프로세스 및 워크플로를 예약하는 방법에 대한 개요
services: logic-apps
ms.suite: integration
ms.reviewer: estfan, logicappspm, azla
ms.topic: conceptual
ms.date: 02/16/2021
ms.openlocfilehash: 1fc565a886698466fce8eaa6ac5ff47ae44be4c9
ms.sourcegitcommit: 7d63ce88bfe8188b1ae70c3d006a29068d066287
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/22/2021
ms.locfileid: "114458833"
---
# <a name="schedule-and-run-recurring-automated-tasks-processes-and-workflows-with-azure-logic-apps"></a>Azure Logic Apps를 사용하여 반복적인 자동화된 작업, 프로세스 및 워크플로 예약 및 실행

Logic Apps는 일정에 따라 자동화된 반복적인 작업 및 프로세스를 만들고 실행하는 데 도움이 됩니다. 일정 유형의 트리거인 기본 제공 되풀이 트리거 또는 슬라이딩 윈도우 트리거로 시작하는 논리 앱 워크플로를 만들어 나중에 또는 반복적인 간격으로 작업을 즉시 실행할 수 있습니다. HTTP 또는 HTTPS 엔드포인트와 같은 Azure 내부 및 외부에서 서비스를 호출하고, Azure Storage 및 Azure Service Bus와 같은 Azure 서비스에 메시지를 게시하거나, 파일 공유에 업로드된 파일을 가져올 수 있습니다. 되풀이 트리거를 사용하여 작업 실행을 위한 복잡한 일정 및 고급 되풀이를 설정할 수도 있습니다. 기본 제공 일정 트리거 및 작업에 대한 자세한 정보는 [일정 트리거](#schedule-triggers) 및 [작업 예약](#schedule-actions)을 참조하세요. 

> [!TIP]
> 예약된 각 작업에 대해 별도의 논리 앱을 만들거나 [지역 및 구독당 워크플로 제한](../logic-apps/logic-apps-limits-and-config.md#definition-limits)에 실행하지 않고도 반복적인 워크로드를 예약하고 실행할 수 있습니다. 대신, Azure 빠른 시작 템플릿에서 만든 논리 앱 패턴인 [ Azure 빠른 시작 템플릿: Logic Apps 작업 스케줄러](https://github.com/Azure/azure-quickstart-templates/tree/master/quickstarts/microsoft.logic/logicapps-jobscheduler/)를 사용할 수 있습니다.
>
> Logic Apps 작업 스케줄러 템플릿은 TimerJob 논리 앱을 호출하는 CreateTimerJob 논리 앱을 만듭니다. 그런 다음 HTTP 요청을 수행하고 해당 요청에 대한 입력으로 일정을 전달하여 CreateTimerJob 논리 앱을 API로 호출할 수 있습니다. CreateTimerJob 논리 앱에 대한 각 호출은 지정된 일정에 따라 계속 실행되거나 지정된 제한에 도달할 때까지 계속 실행되는 새 TimerJob 인스턴스를 만드는 TimerJob 논리 앱을 호출합니다. 이렇게 하면 인스턴스가 개별 논리 앱 워크플로 정의 또는 리소스가 아니기 때문에 워크플로 제한에 대해 걱정하지 않고 원하는 만큼의 TimerJob 인스턴스를 실행할 수 있습니다.

이 목록에서는 일정 기본 제공 트리거를 사용하여 실행할 수 있는 몇 가지 예제 작업을 보여 줍니다.

* 매일 SQL 저장 프로시저를 실행하는 것과 같이 내부 데이터를 가져옵니다.

* 15분마다 NOAA에서 날씨 보고서를 가져오는 것과 같이 외부 데이터를 가져옵니다.

* 지난 주에 특정 값보다 큰 모든 주문에 대한 요약을 메일로 보내는 것과 같이 보고서 데이터를 보냅니다.

* 주중 매일 사용량이 적은 시간에 오늘 업로드된 이미지를 압축하는 것과 같이 데이터를 처리합니다.

* 3개월보다 오래된 모든 트윗 삭제와 같이 데이터를 정리합니다.

* 앞으로 9개월 동안 매일 오전 1:00시에 백업 서비스에 청구서 푸시와 같이 데이터를 보관합니다.

예를 들어 다음과 같이, 다음 작업을 실행하기 전에 일정 기본 제공 작업을 사용하여 워크플로를 일시 중지할 수도 있습니다.

* 평일까지 기다렸다가 전자 메일로 상태 업데이트 전송

* 다시 시작하고 결과를 검색하기 전에 HTTP 호출이 완료될 때까지 워크플로 지연

이 문서에서는 일정 기본 제공 트리거 및 작업에 대한 기능을 설명합니다.

<a name="schedule-triggers"></a>

## <a name="schedule-triggers"></a>일정 트리거

특정 서비스 또는 시스템과 연결되지 않은 되풀이 트리거 또는 슬라이딩 윈도우 트리거를 사용하여 논리 앱 워크플로를 시작할 수 있습니다. 해당 트리거는 간격 및 빈도(초, 분, 시간, 일, 주 또는 월 수)를 선택하는 지정된 되풀이에 따라 워크플로를 시작하고 실행합니다. 시작 날짜와 시간을 표준 시간대와 함께 설정할 수도 있습니다. 트리거가 발생될 때마다 Logic Apps는 논리 앱에 대한 새 워크플로 인스턴스를 만들고 실행합니다.

해당 트리거 간의 차이는 다음과 같습니다.

* **되풀이**: 지정된 일정에 따라 일정한 시간 간격으로 워크플로를 실행합니다. 예를 들어 중단 또는 워크플로 사용하지 않음으로 인해 트리거 누락이 되풀이되는 경우, 되풀이 트리거는 누락된 되풀이를 처리하지 않고 예약된 다음 간격으로 되풀이를 다시 시작합니다.

  **일** 을 빈도로 선택하는 경우 일 및 분의 시간(예: 매일 2:30)을 지정할 수 있습니다. **주** 를 빈도로 선택하는 경우 수요일, 토요일 등의 요일을 선택할 수도 있습니다. 되풀이 일정에 대한 표준 시간대와 함께 시작 날짜와 시간을 지정할 수도 있습니다.

  > [!TIP]
  > 되풀이에서 특정 [시작 날짜와 시간](#start-time)을 지정하지 않는 경우에는 트리거의 되풀이 설정에도 불구하고 논리 앱을 저장하거나 배포할 때 첫 번째 되풀이가 즉시 실행됩니다. 이 동작을 방지하려면 첫 번째 되풀이를 실행할 시작 날짜와 시간을 제공합니다.
  >
  > 되풀이에서 이후 되풀이를 실행하는 특정 시간과 같은 기타 고급 일정 옵션을 지정하지 않는 경우 해당 되풀이는 마지막 실행 시간을 기준으로 합니다. 결과적으로, 해당 되풀이에 대한 시작 시간은 스토리지 호출 중의 대기 시간과 같은 요소로 인해 드리프트될 수 있습니다. 논리 앱이 되풀이를 누락하지 않도록 하려면, 특히 빈도가 며칠 이상이면 다음 옵션을 시도해 보세요.
  >
  > * **일** 및 **주** 빈도에 대해서만 사용할 수 있는 **해당 시간에 대하여** 와 **해당 분에 대하여** 로 명명된 속성을 사용하여 되풀이의 시작 날짜와 시간 및 후속 되풀이를 실행할 특정 시간을 지정합니다.
  >
  > * 되풀이 트리거가 아니라 [슬라이딩 윈도우 트리거](../connectors/connectors-native-sliding-window.md)를 사용합니다.

  자세히 알아보려면 [되풀이 트리거를 사용하여 되풀이 작업 및 워크플로를 만들고 예약하고 실행하는 방법](../connectors/connectors-native-recurrence.md)을 참조하세요.

* **슬라이딩 윈도우**: 연속 청크로 데이터를 처리하는 일정한 시간 간격으로 워크플로를 실행합니다. 예를 들어 중단 또는 워크플로 사용하지 않음으로 인해 트리거 누락이 되풀이되면 슬라이딩 윈도우 트리거가 뒤로 이동하여 누락된 되풀이를 처리합니다.

  시작 날짜 및 시간, 표준 시간대 및 워크플로의 각 되풀이를 지연하는 기간을 지정할 수 있습니다. 이 트리거는 일의 특정 시간, 시간의 특정 분, 주의 특정 요일과 같은 고급 일정을 지원하지 않습니다. 자세히 알아보려면 [슬라이딩 윈도우 트리거를 사용하여 되풀이 작업 및 워크플로를 만들고 예약하고 실행하는 방법](../connectors/connectors-native-sliding-window.md)을 참조하세요.

<a name="schedule-actions"></a>

## <a name="schedule-actions"></a>작업 예약

논리 앱 워크플로의 모든 작업 후에는 다음 작업이 실행되기 전에 워크플로가 대기할 수 있도록 지연 및 다음 기간까지 지연 작업을 사용할 수 있습니다.

* **지연**: 초, 분, 시간, 일, 주 또는 월과 같은 시간 단위의 지정된 수에 대하여 다음 작업을 실행하기 위해 기다립니다. 자세한 내용은 [워크플로에서 다음 작업 지연](../connectors/connectors-native-delay.md)을 참조하세요.

* **다음 기간까지 지연**: 지정된 날짜 및 시간까지 다음 작업을 실행하기 위해 기다립니다. 자세한 내용은 [워크플로에서 다음 작업 지연](../connectors/connectors-native-delay.md)을 참조하세요.

<a name="start-time"></a>

## <a name="patterns-for-start-date-and-time"></a>시작 날짜 및 시간 패턴

시작 날짜 및 시간으로 되풀이를 제어하는 방법과 Logic Apps 서비스에서 해당 되풀이를 실행하는 방법을 보여 주는 몇 가지 패턴은 다음과 같습니다.

| 시작 시간 | 일정 없이 되풀이 | 일정이 있는 되풀이(되풀이 트리거만 해당) |
|------------|-----------------------------|----------------------------------------------------|
| {없음} | 첫 번째 워크로드를 즉시 실행합니다. <p>마지막 실행 시간을 기반으로 이후 워크로드를 실행합니다. | 첫 번째 워크로드를 즉시 실행합니다. <p>지정된 일정을 기반으로 이후 워크로드를 실행합니다. |
| 과거 시작 시간 | **되풀이** 트리거: 지정한 시작 시간을 기반으로 실행 시간을 계산하고, 과거 실행 시간을 버립니다. <p><p>다음 이후 실행 시간에 첫 번째 워크로드를 실행합니다. <p><p>마지막 실행 시간을 기반으로 이후 워크로드를 실행합니다. <p><p>**슬라이딩 윈도우** 트리거: 지정된 시작 시간을 기준으로 실행 시간을 계산하고 이전 실행 시간을 적용합니다. <p><p>지정된 시작 시간을 기반으로 이후 워크로드를 실행합니다. <p><p>자세한 설명은 이 표 다음에 나오는 예를 참조하세요. | 첫 번째 워크로드는 시작 시간으로부터 계산된 일정을 기반으로 하며, 시작 시간보다 *더 일찍* 실행되지 않습니다. <p><p>지정된 일정을 기반으로 이후 워크로드를 실행합니다. <p><p>**참고:** 일정을 사용하여 되풀이를 지정하되 일정에 시간 또는 분을 지정하지 않은 경우, 이후 실행 시간은 각각 시작 실행 시간의 시간 또는 분을 사용하여 계산됩니다. |
| 현재 또는 이후 시작 시간 | 지정된 시작 시간에 첫 번째 워크로드를 실행합니다. <p><p>**되풀이** 트리거: 마지막 실행 시간을 기반으로 이후 워크로드를 실행합니다. <p><p>**슬라이딩 윈도우** 트리거: 지정된 시작 시간을 기준으로 이후 워크로드를 실행합니다. | 첫 번째 워크로드는 시작 시간으로부터 계산된 일정을 기반으로 하며, 시작 시간보다 *더 일찍* 실행되지 않습니다. <p><p>지정된 일정을 기반으로 이후 워크로드를 실행합니다. <p>**참고:** 일정을 사용하여 되풀이를 지정하되 일정에 시간 또는 분을 지정하지 않은 경우, 이후 실행 시간은 각각 시작 실행 시간의 시간 또는 분을 사용하여 계산됩니다. |
||||

*지난 시작 시간 및 되풀이는 있지만 일정은 없는 경우의 예제*

현재 날짜와 시간을 2017년 9월 8일 오후 1:00로 가정합니다. 시작 날짜 및 시간은 과거인 2017년 9월 7일 오후 2:00로 지정하고 2일마다 실행되는 되풀이를 지정합니다.

| 시작 시간 | 현재 시간 | 되풀이 | 예약 |
|------------|--------------|------------|----------|
| 2017-09-**07** T14:00:00Z <br>(2017-09-**07** 2:00 PM) | 2017-09-**08** T13:00:00Z <br>(2017-09-**08** 1:00 PM) | 2일마다 | {없음} |
|||||

되풀이 트리거의 경우 Logic Apps 엔진은 시작 시간을 기준으로 실행 시간을 계산하고, 이전 실행 시간을 삭제하고, 첫 번째 실행에 대한 다음 이후 시작 시간을 사용하고, 마지막 실행 시간을 기준으로 이후 실행을 계산합니다.

이 되풀이는 다음과 같이 작동합니다.

| 시작 시간 | 첫 번째 실행 시간 | 이후 실행 시간 |
|------------|----------------|------------------|
| 2017-09-**07** 2:00 PM | 2017-09-**09** 2:00 PM | 2017-09-**11** 2:00 PM </br>2017-09-**13** 2:00 PM </br>2017-09-**15** 2:00 PM </br>이후 계속됨... |
||||

따라서 지정한 시작 시간이 아무리 먼 과거였어도, 예를 들어 2017-09-**05** 2:00 PM이든 2017-09-**01** 2:00 PM이든, 첫 번째 실행은 언제나 다음 이후 시작 시작을 사용합니다.

슬라이딩 윈도우 트리거의 경우 Logic Apps 엔진은 시작 시간을 기준으로 실행 시간을 계산하고, 이전 실행 시간을 적용하고, 첫 번째 실행에 대한 시작 시간을 사용하며, 시작 시간을 기준으로 이후 실행을 계산합니다.

이 되풀이는 다음과 같이 작동합니다.

| 시작 시간 | 첫 번째 실행 시간 | 이후 실행 시간 |
|------------|----------------|------------------|
| 2017-09-**07** 2:00 PM | 2017-09-**08** 1:00 PM(현재 시간) | 2017-09-**09** 2:00 PM </br>2017-09-**11** 2:00 PM </br>2017-09-**13** 2:00 PM </br>2017-09-**15** 2:00 PM </br>이후 계속됨... |
||||

따라서 지정한 시작 시간이 아무리 먼 과거였어도 예를 들어 2017-09-**05** 2:00 PM이든 2017-09-**01** 2:00 PM이든, 첫 번째 실행은 지정된 시작 시간을 사용합니다.

<a name="daylight-saving-standard-time"></a>

## <a name="recurrence-for-daylight-saving-time-and-standard-time"></a>일광 절약 시간 및 표준 시간에 대한 되풀이

반복적인 기본 제공 트리거는 사용자가 지정하는 표준 시간대를 포함하여 사용자가 설정한 일정을 적용합니다. 표준 시간대를 선택하지 않으면 트리거가 실행될 때 DST(일광 절약 시간)에 영향을 줄 수 있습니다. 예를 들어 DST가 시작될 때 시작 시간을 1시간 앞으로 이동하고, DST가 종료되면 1시간 뒤로 이동합니다. 작업을 예약할 때 Logic Apps는 메시지를 처리하기 위해 큐에 배치하고 마지막 작업이 실행된 UTC 시간과 다음 작업이 실행되도록 예약된 UTC 시간을 기준으로 메시지를 사용할 수 있는 시기를 지정합니다.

논리 앱이 지정된 시작 시간에 실행되도록 이 이동 작업을 방지하려면 표준 시간대를 선택해야 합니다. 이렇게 하면 논리 앱에 대한 UTC 시간도 계절 시간 변경에 대한 카운터로 이동됩니다.

<a name="dst-window"></a>

> [!NOTE]
> 오전 2:00-3:00 사이에 시작하는 트리거는 DST 변경이 오전 2:00에 발생하여 시작 시간이 잘못되거나 모호할 수 있기 때문에 문제가 발생할 수 있습니다. 동일한 모호한 간격 내에 여러 논리 앱이 있는 경우 겹칠 수 있습니다. 이러한 이유로 오전 2:00-3:00 사이에 시작 시간을 피해야 할 수 있습니다.

예를 들어 매일 실행되는 두 개의 논리 앱이 있다고 가정합니다. 하나의 논리 앱이 현지 시간 오전 1:30에 실행되는 반면 다른 논리 앱은 현지 시간으로 오전 2:30에 실행됩니다. DST가 시작 및 종료될 때 해당 앱에 대한 시작 시간은 어떻게 되나요?

* 시간이 1시간 앞으로 이동하면 트리거가 실행되나요?

* 시간이 한 시간 뒤로 이동하면 트리거가 두 번 실행되나요?

해당 논리 앱이 UTC-6:00 중부 표준시(미국 및 캐나다) 영역을 사용하는 경우 이 시뮬레이션에서는 DST 변경 내용을 카운터하기 위해 2019에서 UTC 시간이 이동된 방법을 보여 줍니다. 그러면 앱이 건너뛰거나 중복된 실행 없이 예상된 현지 시간에 계속 실행되도록 하는 데 필요한 대로 한 시간 뒤로 또는 앞으로 이동합니다.

* **03/10/2019: DST가 오전 2:00에 시작되어 1시간 앞으로 이동**

  DST가 시작된 후 보정하기 위해, UTC 시간은 한 시간 뒤로 이동하여 다음과 같이 논리 앱이 동일한 현지 시간에 계속 실행되도록 합니다.

  * 논리 앱 #1

    | Date | 시간(현지) | 시간(UTC) | 참고 |
    |------|--------------|------------|-------|
    | 03/09/2019 | 1:30:00 AM | 7:30:00 AM | DST가 적용되는 날짜 전의 UTC입니다. |
    | 03/10/2019 | 1:30:00 AM | 7:30:00 AM | DST가 적용되지 않았기 때문에 UTC는 동일합니다. |
    | 03/11/2019 | 1:30:00 AM | 오전 6:30:00 | DST가 적용된 후 UTC가 한 시간 뒤로 이동합니다. |
    |||||

  * 논리 앱 #2

    | Date | 시간(현지) | 시간(UTC) | 참고 |
    |------|--------------|------------|-------|
    | 03/09/2019 | 2:30:00 AM | 8:30:00 AM | DST가 적용되는 날짜 전의 UTC입니다. |
    | 03/10/2019 | 3:30:00 AM* | 8:30:00 AM | DST가 이미 적용되어 UTC-6:00 표준 시간대가 UTC-5:00로 변경되므로 현지 시간이 1시간 앞으로 이동했습니다. 자세한 내용은 [오전 2:00 - 3:00 사이에 시작하는 트리거](#dst-window)를 참조하세요. |
    | 03/11/2019 | 2:30:00 AM | 7:30:00 AM | DST가 적용된 후 UTC가 한 시간 뒤로 이동합니다. |
    |||||

* **11/03/2019: DST가 오전 2:00에 종료되고 시간을 한 시간 뒤로 이동합니다.**

  보완하기 위해 논리 앱이 동일한 현지 시간에 계속 실행되도록 UTC 시간이 1시간 앞으로 이동합니다.

  * 논리 앱 #1

    | Date | 시간(현지) | 시간(UTC) | 참고 |
    |------|--------------|------------|-------|
    | 11/02/2019 | 1:30:00 AM | 오전 6:30:00 ||
    | 11/03/2019 | 1:30:00 AM | 오전 6:30:00 ||
    | 11/04/2019 | 1:30:00 AM | 7:30:00 AM ||
    |||||

  * 논리 앱 #2

    | Date | 시간(현지) | 시간(UTC) | 참고 |
    |------|--------------|------------|-------|
    | 11/02/2019 | 2:30:00 AM | 7:30:00 AM ||
    | 11/03/2019 | 2:30:00 AM | 8:30:00 AM ||
    | 11/04/2019 | 2:30:00 AM | 8:30:00 AM ||
    |||||

<a name="run-once"></a>

## <a name="run-one-time-only"></a>한 번만 실행

나중에 한 번에 논리 앱을 실행하려는 경우 **Scheduler: 한 번 실행 작업** 템플릿을 사용할 수 있습니다. 새 논리 앱을 만든 후 Logic Apps Designer를 열기 전에 **템플릿** 섹션의 **범주** 목록에서 **일정** 을 선택하고 다음 템플릿을 선택합니다.

![“Scheduler: 한 번 실행 작업” 템플릿을 선택합니다.](./media/concepts-schedule-automated-recurring-tasks-workflows/choose-run-once-template.png)

또는 **HTTP 요청을 받을 때 - 요청** 트리거를 사용하여 논리 앱을 시작할 수 있는 경우 시작 시간을 트리거의 매개 변수로 전달합니다. 첫 번째 작업의 경우 **다음 기간까지 지연 - 일정** 작업을 사용하고, 다음 작업 실행을 시작할 때의 시간을 제공합니다.

<a name="run-once-last-day-of-the-month"></a>

## <a name="run-once-at-last-day-of-the-month"></a>매월 마지막 날에 한 번 실행

매월 마지막 날에 한 번만 되풀이 트리거를 실행하려면 디자이너가 아닌 코드 보기를 사용하여 워크플로의 기본 JSON 정의에서 트리거를 편집해야 합니다. 그러나 다음 예제를 사용할 수 있습니다.

```json
"triggers": {
    "Recurrence": {
        "recurrence": {
            "frequency": "Month",
            "interval": 1,
            "schedule": {
                "monthDays": [-1]
            }
        },
        "type": "Recurrence"
    }
}
```

<a name="example-recurrences"></a>

## <a name="example-recurrences"></a>예제 되풀이

다음은 옵션을 지원하는 트리거에 대해 설정할 수 있는 다양한 예제 되풀이입니다.

| 트리거 | 되풀이 | 간격 | 빈도 | 시작 시간 | 요일 선택 | 시간 선택 | 분 선택 | 참고 |
|---------|------------|----------|-----------|------------|---------------|----------------|------------------|------|
| 되풀이, <br>슬라이딩 윈도우 | 15분마다 실행(시작 날짜와 시간 없음) | 15 | Minute | {없음} | {사용할 수 없음} | {없음} | {없음} | 이 일정은 즉시 시작된 다음, 마지막 실행 시간을 기반으로 이후 되풀이 간격을 계산합니다. |
| 되풀이, <br>슬라이딩 윈도우 | 15분마다 실행(시작 날짜와 시간 있음) | 15 | Minute | *startDate* T *startTime* Z | {사용할 수 없음} | {없음} | {없음} | 이 일정은 지정된 시작 날짜 및 시간보다 *더 일찍* 시작되지 않으며, 마지막 실행 시간을 기반으로 이후 되풀이 간격을 계산합니다. |
| 되풀이, <br>슬라이딩 윈도우 | 해당 시간에 시간마다 실행(시작 날짜 및 시간 있음) | 1 | 시간 | *startDate* Thh:00:00Z | {사용할 수 없음} | {없음} | {없음} | 이 일정은 지정된 시작 날짜 및 시간보다 *더 일찍* 시작되지 않습니다. 이후 되풀이는 “00”분 표시에서 1시간마다 실행되며 이는 Logic Apps가 시작 시간에서 계산합니다. <p>빈도가 “주” 또는 “월”인 경우 이 일정은 주당 한 요일 또는 달마다 하루에 각각 실행됩니다. |
| 되풀이, <br>슬라이딩 윈도우 | 매일 시간마다 실행(시작 날짜와 시간 없음) | 1 | 시간 | {없음} | {사용할 수 없음} | {없음} | {없음} | 이 일정은 즉시 시작되고 마지막 실행 시간을 기반으로 이후 되풀이 간격을 계산합니다. <p>빈도가 “주” 또는 “월”인 경우 이 일정은 주당 한 요일 또는 달마다 하루에 각각 실행됩니다. |
| 되풀이, <br>슬라이딩 윈도우 | 매일 시간마다 실행(시작 날짜와 시간 있음) | 1 | 시간 | *startDate* T *startTime* Z | {사용할 수 없음} | {없음} | {없음} | 이 일정은 지정된 시작 날짜 및 시간보다 *더 일찍* 시작되지 않으며, 마지막 실행 시간을 기반으로 이후 되풀이 간격을 계산합니다. <p>빈도가 “주” 또는 “월”인 경우 이 일정은 주당 한 요일 또는 달마다 하루에 각각 실행됩니다. |
| 되풀이, <br>슬라이딩 윈도우 | 시간마다 15분 간격으로 실행(시작 날짜 및 시간 있음) | 1 | 시간 | *startDate* T00:15:00Z | {사용할 수 없음} | {없음} | {없음} | 이 일정은 지정된 시작 날짜 및 시간보다 *더 일찍* 시작되지 않습니다. 이후 되풀이는 “15”분 표시에서 실행되며, 이는 Logic Apps가 시작 시간에서 계산하여 오전 00:15, 오전 1:15, 2:15 AM 등입니다. |
| 되풀이 | 시간마다 15분 간격으로 실행(시작 날짜 및 시간 없음) | 1 | 일 | {없음} | {사용할 수 없음} | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | 15 | 이 일정은 00:15 AM, 1:15 AM, 2:15 AM에서 실행됩니다. 또한 이 일정은 “시간” 빈도 및 “15”분 시작 시간과 동일합니다. |
| 되풀이 | 지정된 분 표시에서 15분마다 실행(시작 날짜와 시간 없음) | 1 | 일 | {없음} | {사용할 수 없음} | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | 0, 15, 30, 45 | 이 일정은 다음 지정한 15분 표시까지 시작되지 않습니다. |
| 되풀이 | 논리 앱을 저장할 때 매일 오전 8시 *그리고* 분 표시를 실행합니다. | 1 | 일 | {없음} | {사용할 수 없음} | 8 | {없음} | 시작 날짜와 시간이 없으면 이 일정은 논리 앱(PUT 작업)을 저장하는 시간에 따라 실행됩니다. |
| 되풀이 | 매일 오전 8:00에 실행(시작 날짜와 시간 있음) | 1 | 일 | *startDate* T08:00:00Z | {사용할 수 없음} | {없음} | {없음} | 이 일정은 지정된 시작 날짜 및 시간보다 *더 일찍* 시작되지 않습니다. 이후 발생 횟수는 매일 오전 8:00에 실행됩니다. | 
| 되풀이 | 매일 오전 8:00에 실행(시작 날짜와 시간 없음) | 1 | 일 | {없음} | {사용할 수 없음} | 8 | 00 | 이 일정은 매일 오전 8:00에 실행됩니다. |
| 되풀이 | 매일 오전 8:00와 오후 4:00에 실행 | 1 | 일 | {없음} | {사용할 수 없음} | 8, 16 | 0 | |
| 되풀이 | 매일 오전 8:30, 오전 8:45, 오후 4:30, 오후 4:45에 실행 | 1 | 일 | {없음} | {사용할 수 없음} | 8, 16 | 30, 45 | |
| 되풀이 | 매주 토요일 오후 5시에 실행(시작 날짜와 시간 없음) | 1 | 주 | {없음} | “토요일” | 17 | 0 | 이 일정은 매주 토요일 5:00 PM에 실행됩니다. |
| 되풀이 | 매주 토요일 오후 5시에 실행(시작 날짜와 시간 있음) | 1 | 주 | *startDate* T17:00:00Z | “토요일” | {없음} | {없음} | 이 일정은 지정된 시작 날짜 및 시간(이 경우 2017년 9월 9일 5:00 PM)보다 *더 일찍* 시작되지 않습니다. 이후 되풀이는 매주 토요일 5:00 PM에 실행됩니다. |
| 되풀이 | 매주 화요일, 목요일 오후 5시 *그리고* 논리 앱을 저장할 때의 분 표시를 실행합니다.| 1 | 주 | {없음} | “화요일”, “목요일” | 17 | {없음} | |
| 되풀이 | 근무 시간 동안 1시간마다 실행 | 1 | 주 | {없음} | 토요일과 일요일을 제외한 모든 날짜를 선택합니다. | 원하는 하루 시간을 선택합니다. | 원하는 시간의 분을 선택합니다. | 예를 들어, 근무 시간이 오전 8:00 ~ 오후 5:00인 경우 “8, 9, 10, 11, 12, 13, 14, 15, 16, 17”을 하루 시간으로 *그리고* “0”을 해당 시각의 분으로 선택합니다. |
| 되풀이 | 주말에 매일 한 번 실행 | 1 | 주 | {없음} | “토요일”, “일요일” | 원하는 하루 시간을 선택합니다. | 적절한 시간의 분을 선택합니다. | 이 일정은 지정된 일정에 토요일과 일요일마다 실행됩니다. |
| 되풀이 | 월요일에만 격주로 15분마다 실행 | 2 | 주 | {없음} | “월요일” | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | 0, 15, 30, 45 | 이 일정은 월요일마다 격주로 15분 표시에 실행됩니다. |
| 되풀이 | 매월 실행 | 1 | 월 | *startDate* T *startTime* Z | {사용할 수 없음} | {사용할 수 없음} | {사용할 수 없음} | 이 일정은 지정된 시작 날짜 및 시간보다 더 *일찍* 시작되지 않으며 시작 날짜와 시간에 대한 이후 되풀이를 계산합니다. 시작 날짜 및 시간을 지정하지 않은 경우 이 일정은 만든 날짜 및 시간을 사용합니다. |
| 되풀이 | 매달 하루 동안 1시간마다 실행 | 1 | 월 | {참고 참조} | {사용할 수 없음} | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | {참고 참조} | 시작 날짜 및 시간을 지정하지 않은 경우 이 일정은 만든 날짜 및 시간을 사용합니다. 되풀이 일정에 대한 분을 제어하려면 시간의 분, 시작 시간을 지정하거나 만든 시간을 사용합니다. 예를 들어 시작 시간 또는 만든 시간이 8:25 AM인 경우 이 일정은 8:25 AM, 9:25 AM, 10:25 AM 등에 실행됩니다. |
|||||||||

## <a name="next-steps"></a>다음 단계

* [되풀이 트리거를 사용하여 되풀이 작업 및 워크플로를 만들고 예약하고 실행하는 방법](../connectors/connectors-native-recurrence.md)
* [슬라이딩 윈도우 트리거를 사용하여 반복적인 작업 및 워크플로를 만들고 예약하고 실행하는 방법](../connectors/connectors-native-sliding-window.md)
* [지연 작업을 사용하여 워크플로 일시 중지](../connectors/connectors-native-delay.md)
