---
title: 서비스 계층 - DTU 기반 구매 모델
description: 컴퓨팅 및 스토리지 크기를 제공하기 위한 Azure SQL Database에 대한 DTU 기반 구매 모델의 서비스 계층에 대해 알아봅니다.
services: sql-database
ms.service: sql-database
ms.subservice: service-overview
ms.custom: references_regions
ms.devlang: ''
ms.topic: conceptual
author: dimitri-furman
ms.author: dfurman
ms.reviewer: mathoma
ms.date: 5/4/2021
ms.openlocfilehash: c5413918923ebb4e613ecb48e86dbccfcc60889b
ms.sourcegitcommit: 20acb9ad4700559ca0d98c7c622770a0499dd7ba
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/29/2021
ms.locfileid: "110693286"
---
# <a name="service-tiers-in-the-dtu-based-purchase-model"></a>DTU 기반 구매 모델에서 서비스 계층
[!INCLUDE[appliesto-sqldb](../includes/appliesto-sqldb.md)]

DTU 기반 구매 모델에서 서비스 계층은 포함된 스토리지의 고정된 양, 고정된 백업 보존 기간 및 고정 가격을 갖춘 다양한 컴퓨팅 크기로 구분됩니다. DTU 기반 구매 모델의 모든 서비스 계층은 [가동 중지 시간](https://azure.microsoft.com/support/legal/sla/sql-database/v1_2/)을 최소화하면서 컴퓨팅 크기를 유연하게 변경할 수 있습니다. 그러나 짧은 시간 동안 데이터베이스에 대한 연결이 끊어지는 전환 기간이 있는데, 이는 다시 시도 논리를 사용하여 완화할 수 있습니다. 단일 데이터베이스 및 탄력적 풀은 서비스 계층 및 컴퓨팅 크기에 따라 시간 단위로 청구됩니다.

> [!IMPORTANT]
> [Azure SQL Managed Instance](../managed-instance/sql-managed-instance-paas-overview.md)는 DTU 기반 구매 모델을 지원하지 않습니다. 


> [!NOTE]
> vCore 기반 서비스 계층에 대한 내용은 [vCore 기반 서비스 계층](service-tiers-vcore.md)을 참조하세요. DTU 기반 서비스 계층과 vCore 기반 서비스 계층을 구분하는 방법에 대한 자세한 내용은 [구매 모델](purchasing-models.md)을 참조하세요.

## <a name="compare-the-dtu-based-service-tiers"></a>DTU 기반 서비스 계층 비교

서비스 계층을 선택하는 작업은 주로 비즈니스 연속성, 스토리지 및 성능 요구 사항에 따라 다릅니다.

||Basic|Standard|Premium|
| :-- | --: |--:| --:|
|**대상 워크로드**|개발 및 프로덕션|개발 및 프로덕션|개발 및 프로덕션|
|**작동 시간 SLA**|99.99%|99.99%|99.99%|
|**최대 백업 보존**|7 일|35일|35일|
|**CPU**|낮음|낮음, 보통, 높음|보통, 높음|
|**IOPS(대략적인 크기)** \* |DTU당 1-4 IOPS| DTU당 1-4 IOPS | DTU당 25 IOPS 초과|
|**IO 대기 시간(근사치)**|5ms(읽기), 10ms(쓰기)|5ms(읽기), 10ms(쓰기)|2ms(읽기/쓰기)|
|**Columnstore 인덱싱** |해당 없음|S3 이상|지원됨|
|**메모리 내 OLTP**|해당 없음|해당 없음|지원됨|

\* 백그라운드 IO(검사점 및 지연 기록기)를 포함하여 데이터 파일에 대한 모든 읽기 및 쓰기 IOPS

> [!IMPORTANT]
> 기본, S0, S1 및 S2 서비스 개체는 하나 미만의 vCore (CPU)를 제공합니다.  CPU를 많이 사용하는 워크로드의 경우에는 S3 이상의 서비스 개체가 권장됩니다. 
>
> 기본, S0 및 S1 서비스 개체에서 데이터베이스 파일은 HDD(하드 디스크 드라이브) 기반 저장소 미디어를 사용하는 Azure Standard Storage에 저장됩니다. 이러한 서비스 개체는 성능 변동에 덜 민감한 개발, 테스트 및 기타 자주 액세스하지 않는 워크로드에 가장 적합합니다.
>

> [!TIP]
> 데이터베이스 또는 탄력적 풀에 대한 실제 [리소스 거버넌스](resource-limits-logical-server.md#resource-governance) 제한을 보려면 [sys.dm_user_db_resource_governance](/sql/relational-databases/system-dynamic-management-views/sys-dm-user-db-resource-governor-azure-sql-database) 보기를 쿼리합니다.

> [!NOTE]
> Azure를 탐색해 보려면 Azure 체험 계정과 연결된 기본 서비스 계층에서 무료 Azure SQL Database를 얻을 수 있습니다. 자세한 내용은 [Azure 체험 계정으로 관리되는 클라우드 데이터베이스 만들기](https://azure.microsoft.com/free/services/sql-database/)를 참조하세요.

## <a name="single-database-dtu-and-storage-limits"></a>단일 데이터베이스 DTU 및 스토리지 제한

컴퓨팅 크기는 단일 데이터베이스에 대해서는 DTU(데이터베이스 트랜잭션 단위), 탄력적 풀에 대해서는 eDTU(탄력적 데이터베이스 트랜잭션 단위)로 표현됩니다. DTU 및 eDTU에 대한 자세한 내용은 [DTU 기반 구매 모델](purchasing-models.md#dtu-based-purchasing-model)을 참조하세요.

||Basic|Standard|Premium|
| :-- | --: | --: | --: |
| **최대 스토리지 크기** | 2GB | 1TB | 4 TB  |
| **최대 DTU** | 5 | 3000 | 4000 |

> [!IMPORTANT]
> 경우에 따라 사용하지 않는 공간을 회수하기 위해 데이터베이스를 축소해야 할 수도 있습니다. 자세한 내용은 [Azure SQL Database의 파일 공간 관리](file-space-manage.md)를 참조하세요.

## <a name="elastic-pool-edtu-storage-and-pooled-database-limits"></a>탄력적 풀 eDTU, 스토리지 및 풀링된 데이터베이스 제한

|| **기본** | **Standard** | **Premium** |
| :-- | --: | --: | --: |
| **데이터베이스당 최대 스토리지 크기**  | 2GB | 1TB | 1TB |
| **풀당 최대 스토리지 크기** | 156GB | 4 TB | 4 TB |
| **데이터베이스당 최대 eDTU** | 5 | 3000 | 4000 |
| **풀당 최대 eDTU** | 1600 | 3000 | 4000 |
| **풀당 최대 데이터베이스 수** | 500  | 500 | 100 |

> [!IMPORTANT]
> 현재 일부 예외 지역 이외의 모든 지역에서 프리미엄 계층의 스토리지는 1TB를 초과하여 사용할 수 있습니다(예외 지역: 중국 동부, 중국 북부, 독일 중부, 독일 북동부). 이러한 지역에서 프리미엄 계층 스토리지 최대 크기는 1TB로 제한됩니다.  자세한 내용은 [P11-P15 현재 제한 사항](single-database-scale.md#p11-and-p15-constraints-when-max-size-greater-than-1-tb)을 참조하세요.  
> [!IMPORTANT]
> 경우에 따라 사용하지 않는 공간을 회수하기 위해 데이터베이스를 축소해야 할 수도 있습니다. 자세한 내용은 [Azure SQL Database의 파일 공간 관리](file-space-manage.md)를 참조하세요.

## <a name="dtu-benchmark"></a>DTU 벤치마크

각 DTU 측정값에 연결된 물리적 특성(CPU, 메모리, IO)은 실제 데이터베이스 워크로드를 시뮬레이션하는 벤치마크를 사용하여 보정됩니다.

### <a name="correlating-benchmark-results-to-real-world-database-performance"></a>벤치마크 결과와 실제 데이터베이스 성능 간 상관 관계 분석

모든 벤치마크는 대표적, 암시적 수치임을 이해하는 것이 중요합니다. 벤치마크 애플리케이션에서 달성한 트랜잭션 속도는 다른 애플리케이션에서 달성할 수 있는 속도와 동일하지 않습니다. 벤치마크는 다양한 테이블 및 데이터 유형이 포함된 스키마에 대해 실행되는 다양한 트랜잭션 유형의 컬렉션으로 구성되어 있습니다. 벤치마크는 모든 OLTP 워크로드에 공통적이고 동일한 기본 작업을 실행하며 특정 클래스의 데이터베이스 또는 애플리케이션을 나타내지 않습니다. 벤치마크의 목표는 컴퓨팅 크기를 확장 또는 축소할 경우 예상할 수 있는 데이터베이스의 상대적 성능에 대한 합리적 지침을 제공하는 것입니다. 실제로, 각 데이터베이스는 크기와 복잡성이 다르고 다양하게 혼합된 워크로드를 처리할 수 있으며 각각 다른 방식으로 대응합니다. 예를 들어, IO를 많이 사용하는 애플리케이션은 IO 임계값에 빠르게 도달할 수 있고 CPU를 많이 사용하는 애플리케이션은 CPU 한도에 빠르게 도달할 수 있습니다. 부하가 증가할 때 특정 데이터베이스가 벤치마크와 동일하게 확장된다는 보장이 없습니다.

벤치마크와 그 방법론은 아래에서 더 자세히 설명합니다.

### <a name="benchmark-summary"></a>벤치마크 요약

벤치마크는 OLTP(온라인 트랜잭션 처리) 워크로드에서 가장 빈번하게 발생하는 기본 데이터베이스 작업의 성능을 측정합니다. 클라우드 컴퓨팅을 예상하고 벤치마크를 설계했지만, 데이터베이스 스키마, 데이터 채우기, 트랜잭션은 OLTP 워크로드에서 가장 일반적으로 사용되는 기본 요소를 광범위하게 나타내도록 설계되었습니다.

### <a name="schema"></a>스키마

스키마는 다양한 작업을 지원하도록 다양하고 복잡하게 설계되었습니다. 벤치마크는 6개의 테이블로 구성된 데이터베이스에 실행합니다. 테이블은 고정 크기, 확장, 증가의 세 범주로 구분됩니다. 2개의 고정 크기 테이블, 3개의 확장 테이블, 1개의 증가 테이블이 있습니다. 고정 크기 테이블에는 고정된 수의 행이 있습니다. 확장 테이블에는 데이터베이스 성능에 비례하는 카디널리티가 있지만 벤치마크 중에는 변경되지 않습니다. 증가 테이블은 초기 로드 시 확장 테이블과 같은 크기이지만, 행을 삽입 및 증가하면서 벤치마크를 실행하는 동안 카디널리티가 변경됩니다.

스키마에는 정수, 숫자, 문자, 날짜/시간 등 혼합된 데이터 유형이 포함되어 있습니다. 스키마에는 기본 및 보조 키가 포함되어 있지만 외부 키가 없습니다. 즉, 테이블 간 참조 무결성 제약 조건이 없습니다.

데이터 생성 프로그램은 초기 데이터베이스의 데이터를 생성합니다. 정수 및 숫자 데이터는 다양한 전략으로 생성됩니다. 값이 범위에 무작위로 분포되는 경우도 있습니다. 또한 특정 분포를 유지하기 위해 값 집합을 무작위로 변경하는 경우도 있습니다. 가중치를 적용한 단어 목록에서 텍스트 필드를 생성하여 현실적 데이터를 만듭니다.

데이터베이스는 "배율"을 기준으로 크기를 조정합니다. 배율(약어: SF)은 확장 및 증가 테이블의 카디널리티를 결정합니다. 아래의 사용자 및 속도 섹션에 설명된 대로 데이터베이스 크기, 사용자 수, 최대 성능은 모두 서로에 비례하여 확장됩니다.

### <a name="transactions"></a>트랜잭션

워크로드는 아래 표와 같이 9가지 트랜잭션 유형으로 구성되어 있습니다. 각 트랜잭션은 다른 트랜잭션과 크게 대비되도록 데이터베이스 엔진 및 시스템 하드웨어에서 특정 시스템 집합의 특성을 강조하도록 설계되었습니다. 이 방식에서는 다양한 구성 요소가 전반적 성능에 미치는 영향을 쉽게 평가할 수 있습니다. 예를 들어 "읽기 작업이 많은" 트랜잭션은 디스크에서 많은 읽기 작업을 만듭니다.

| 트랜잭션 유형 | 설명 |
| --- | --- |
| 적은 읽기 작업 |SELECT, 메모리 내, 읽기 전용 |
| 중간 읽기 작업 |SELECT, 대부분 메모리 내, 읽기 전용 |
| 많은 읽기 작업 |SELECT, 대부분 메모리 외, 읽기 전용 |
| 적은 업데이트 작업 |UPDATE, 메모리 내, 읽기-쓰기 |
| 많은 업데이트 작업 |UPDATE, 대부분 메모리 외, 읽기-쓰기 |
| 적은 삽입 작업 |INSERT, 메모리 내, 읽기-쓰기 |
| 많은 삽입 작업 |INSERT, 대부분 메모리 외, 읽기-쓰기 |
| DELETE |DELETE, 메모리 내 및 메모리 외 혼합, 읽기-쓰기 |
| 많은 CPU 사용 |SELECT, 메모리 내, 상대적으로 많은 CPU 부하, 읽기 전용 |

### <a name="workload-mix"></a>워크로드 혼합

가중치를 적용한 분포에서 다음과 같은 전반적 혼합을 적용하여 무작위로 트랜잭션을 선택합니다. 전반적 혼합은 읽기/쓰기 비율이 약 2:1입니다.

| 트랜잭션 유형 | 혼합 비율 |
| --- | --- |
| 적은 읽기 작업 |35 |
| 중간 읽기 작업 |20 |
| 많은 읽기 작업 |5 |
| 적은 업데이트 작업 |20 |
| 많은 업데이트 작업 |3 |
| 적은 삽입 작업 |3 |
| 많은 삽입 작업 |2 |
| DELETE |2 |
| 많은 CPU 사용 |10 |

### <a name="users-and-pacing"></a>사용자 및 속도

벤치마크 워크로드는 연결 집합에 트랜잭션을 제출하는 도구를 기반으로 많은 동시 사용자의 동작을 시뮬레이션합니다. 모든 연결과 트랜잭션이 시스템에서 생성된 것이지만, 간단히 이러한 연결을 "사용자"로 지칭합니다. 각 사용자는 나머지 사용자와 독립적으로 운영하지만, 모든 사용자는 아래와 같이 동일한 단계의 주기를 수행합니다.

1. 데이터베이스에 연결합니다.
2. 끝내라는 메시지가 표시될 때까지 계속 반복합니다.
   - (가중치가 적용된 분포에서) 무작위로 트랜잭션을 선택합니다.
   - 선택한 트랜잭션을 수행하고 응답 시간을 측정합니다.
   - 속도 지연을 기다립니다.
3. 데이터베이스 연결을 종료합니다.
4. 종료합니다.

(2c 단계에서) 무작위이지만 평균 1.0초의 분포가 있는 속도 지연을 선택합니다. 따라서 각 사용자는 평균적으로 1초당 최대 1개의 트랜잭션을 생성할 수 있습니다.

### <a name="scaling-rules"></a>확장 규칙

사용자 수는 데이터베이스 크기로 결정됩니다(배율 단위). 5개의 배율 단위당 1명의 사용자가 있습니다. 속도 지연으로 인해 1명의 사용자는 평균적으로 초당 최대 1개의 트랜잭션을 생성할 수 있습니다.

예를 들어, 배율이 500(SF=500)인 데이터베이스는 사용자가 100명이며 최대 100TPS의 속도를 달성할 수 있습니다. TPS 속도를 높이려면 더 많은 사용자와 더 큰 데이터베이스가 필요합니다.

### <a name="measurement-duration"></a>측정 기간

유효한 벤치마크를 실행하려면 한 시간 이상의 안정적 측정 기간이 필요합니다.

### <a name="metrics"></a>메트릭

벤치마크의 핵심 메트릭은 처리량과 응답 시간입니다.

- 처리량은 벤치마크의 필수 성능 측정값입니다. 처리량은 모든 트랜잭션 유형을 세는 단위 시간당 트랜잭션 수로 보고됩니다.
- 응답 시간은 성능 예측 가능성에 대한 측정값입니다. 응답 시간 제약 조건은 서비스 클래스에 따라 달라지며, 다음과 같이 서비스 클래스가 높을수록 응답 시간 요구 사항이 더욱 까다로워집니다.

| 서비스 클래스 | 처리량 측정 | 응답 시간 요구 사항 |
| --- | --- | --- |
| Premium |초당 트랜잭션 수 |0.5초에서 95 백분위수 |
| Standard |분당 트랜잭션 수 |1.0초에서 90 백분위수 |
| Basic |시간당 트랜잭션 수 |2.0초에서 80 백분위수 |

## <a name="next-steps"></a>다음 단계

- 단일 데이터베이스에 사용할 수 있는 특정 컴퓨팅 크기 및 스토리지 크기 선택 방법에 대한 자세한 내용은 [단일 데이터베이스에 대한 SQL Database DTU 기반 리소스 제한](resource-limits-dtu-single-databases.md#single-database-storage-sizes-and-compute-sizes)을 참조하세요.
- 탄력적 풀에 사용할 수 있는 특정 컴퓨팅 크기 및 스토리지 크기를 선택하는 방법에 대한 자세한 내용은 [SQL Database DTU 기반 리소스 제한](resource-limits-dtu-elastic-pools.md#elastic-pool-storage-sizes-and-compute-sizes)을 참조하세요.
