---
title: Integration Runtime 성능
titleSuffix: Azure Data Factory & Azure Synapse
description: Azure Data Factory 및 Azure Synapse Analytics의 Azure Integration Runtime 성능을 최적화하고 개선하는 방법에 대해 알아봅니다.
author: kromerm
ms.topic: conceptual
ms.author: makromer
ms.service: data-factory
ms.subservice: data-flows
ms.custom: synapse
ms.date: 09/09/2021
ms.openlocfilehash: 13f632da70944d7c1aec00df112782429dc9620e
ms.sourcegitcommit: 0770a7d91278043a83ccc597af25934854605e8b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/13/2021
ms.locfileid: "124787910"
---
# <a name="optimizing-performance-of-the-azure-integration-runtime"></a>Azure Integration Runtime 성능 최적화

데이터 흐름은 런타임에 스핀업된 Spark 클러스터에서 실행됩니다. 사용되는 클러스터의 구성은 활동의 IR(통합 런타임)에 정의되어 있습니다. 통합 런타임을 정의할 때 클러스터 유형, 클러스터 크기 및 Time to Live의 세 가지 성능을 고려해야 합니다.

통합 런타임을 만드는 방법에 대한 자세한 내용은 [통합 런타임](concepts-integration-runtime.md)을 참조하세요.

## <a name="cluster-type"></a>클러스터 유형

Spark 클러스터 스핀업 유형에 사용할 수 있는 세 가지 옵션은 범용, 메모리 최적화 및 컴퓨팅 최적화입니다.

**범용** 클러스터는 기본적으로 선택되며 대부분의 데이터 흐름 워크로드에 이상적입니다. 성능과 비용의 균형이 가장 좋습니다.

데이터 흐름에서 조인과 조회가 많이 발생하는 경우 **메모리 최적화** 클러스터를 사용하는 것이 좋습니다. 메모리 최적화 클러스터는 메모리에 더 많은 데이터를 저장할 수 있으며 발생할 수 있는 메모리 부족 오류를 최소화합니다. 메모리 최적화 옵션은 코어당 가격이 가장 높지만 보다 성공적인 파이프라인을 만들 수 있습니다. 데이터 흐름을 실행할 때 메모리 부족 오류가 발생하면 메모리 최적화 Azure IR 구성으로 전환하세요. 

**컴퓨팅 최적화** 는 ETL 워크플로에 적합하지 않으며 대부분의 프로덕션 워크로드에 권장하지 않습니다. 데이터 필터링 또는 파생 열 추가와 같이 메모리를 많이 사용하지 않는 간단한 데이터 변형의 경우 코어당 가격이 저렴한 컴퓨팅 최적화 클러스터를 사용해도 됩니다.

## <a name="cluster-size"></a>클러스터 크기

데이터 흐름은 데이터 처리를 Spark 클러스터의 여러 노드에 분산하여 작업을 병렬로 수행합니다. 더 많은 코어가 있는 Spark 클러스터는 컴퓨팅 환경에서 노드 수를 늘립니다. 노드가 많을수록 데이터 흐름의 처리 성능이 향상됩니다. 클러스터 크기를 늘리면 처리 시간이 단축되는 경우가 많습니다.

기본 클러스터 크기는 드라이버 노드 4개와 작업자 노드 4개입니다.  더 많은 데이터를 처리하는 경우 더 큰 클러스터를 사용하는 것이 좋습니다. 아래는 사용 가능한 크기 옵션입니다.

| 작업자 코어 | 드라이버 코어 | 총 코어 | 참고 |
| ------------ | ------------ | ----------- | ----- |
| 4 | 4 | 8 | 컴퓨팅 최적화에는 사용할 수 없음 |
| 8 | 8 | 16 | |
| 16 | 16 | 32 | |
| 32 | 16 | 48 | |
| 64 | 16 | 80 | |
| 128 | 16 | 144 | |
| 256 | 16 | 272 | |

데이터 흐름은 vCore-시간으로 가격이 책정됩니다. 즉, 클러스터 크기와 실행 시간을 모두 고려합니다. 스케일 업하면 분당 클러스터 비용이 증가하지만 전체 시간이 감소합니다.

> [!TIP]
> 클러스터 크기가 데이터 흐름의 성능에 영향을 미치는 한계가 있습니다. 데이터의 크기에 따라 클러스터 크기를 늘려도 성능이 더 이상 향상되지 않는 지점이 있습니다. 예를 들어 데이터 파티션보다 노드가 더 많은 경우 노드를 더 추가해도 도움이 되지 않습니다. 작게 시작하고 이후에 성능 요구 사항에 맞게 스케일 업하는 것이 가장 좋습니다. 

## <a name="time-to-live"></a>TTL(Time to live)

기본적으로 모든 데이터 흐름 작업은 Azure IR 구성에 따라 새 Spark 클러스터를 스핀업합니다. 콜드 클러스터 시작 시간은 몇 분 정도 걸리며 완료될 때까지 데이터 처리를 시작할 수 없습니다. 파이프라인에 여러 개의 **순차적** 데이터 흐름이 포함된 경우 TTL(Time to Live) 값을 사용할 수 있습니다. Time to Live 값을 지정하면 실행이 완료된 후에도 특정 기간 동안 클러스터가 활성 상태로 유지됩니다. TTL 시간 동안 IR을 사용하여 새 작업이 시작되면 기존 클러스터를 다시 사용하므로 시작 시간이 크게 단축됩니다. 두 번째 작업이 완료되면 클러스터는 다시 TTL 시간 동안 활성 상태로 유지됩니다.

데이터 흐름 속성 아래의 Azure 통합 런타임에 있는 “빠른 다시 사용” 옵션을 설정하여 웜 클러스터의 시작 시간을 추가로 최소화할 수 있습니다. 이를 참으로 설정하면 각 작업 후에 기존 클러스터를 해체하지 않고 기존 클러스터를 다시 사용하도록, 특히 Azure IR에서 설정한 컴퓨팅 환경을 TTL에 지정된 기간까지 활성 상태로 유지하도록 서비스에 지시하게 됩니다. 이 옵션을 사용하면 파이프라인에서 실행될 때 데이터 흐름 활동의 시작 시간이 가장 짧습니다.

그러나 대부분의 데이터 흐름이 병렬로 실행되는 경우 해당 활동에 사용하는 IR에 대해 TTL을 사용하지 않는 것이 좋습니다. 단일 클러스터에서 한 번에 하나의 작업만 실행할 수 있습니다. 사용 가능한 클러스터가 있지만 두 개의 데이터 흐름이 시작되면 하나만 라이브 클러스터를 사용합니다. 두 번째 작업은 자체 격리된 클러스터를 스핀업합니다.

> [!NOTE]
> 자동 해결 통합 런타임을 사용하는 경우 Time to Live를 사용할 수 없습니다.

## <a name="next-steps"></a>다음 단계

성능과 관련된 다음과 같은 다른 데이터 흐름 문서를 참조하세요.

- [데이터 흐름 성능](concepts-data-flow-performance.md)
- [데이터 흐름 작업](control-flow-execute-data-flow-activity.md)
- [데이터 흐름 성능 모니터링](concepts-data-flow-monitoring.md)
